// POWERED BY SPRING DART
// GENERATED CODE - DO NOT MODIFY BY HAND

import 'dart:async';
import 'dart:convert';
import 'dart:core';
import 'package:example/src/config/security_configuration.dart';
import 'package:example/src/config/server_configuration.dart';
import 'package:example/src/config/sqlite_configuration.dart';
import 'package:example/src/controllers/auth_controller.dart';
import 'package:example/src/dtos/sign_in_dto.dart';
import 'package:example/src/dtos/sign_up_dto.dart';
import 'package:example/src/entities/post_entity.dart';
import 'package:example/src/entities/user_entity.dart';
import 'package:example/src/exceptions.dart';
import 'package:example/src/server_controller_advice.dart';
import 'package:example/src/services/auth_service.dart';
import 'package:spring_dart/spring_dart.dart';
import 'package:spring_dart_sql/spring_dart_sql.dart';
import 'package:sqlite3/sqlite3.dart';

Future<void> server(List<String> args) async {
  final getIt = GetIt.instance;
  final router = Router(notFoundHandler: _defaultNotFoundHandler);
  // Configurations
  final securityConfiguration = SecurityConfiguration();
  final sqliteConfiguration = SqliteConfiguration();
  // Beans
  getIt.registerLazySingleton<JwtService>(
    () => securityConfiguration.jwtService(),
  );
  getIt.registerLazySingleton<PasswordService>(
    () => securityConfiguration.passwordService(),
  );
  getIt.registerLazySingletonAsync<Database>(
    () => sqliteConfiguration.database(),
  );
  await GetIt.instance.allReady();
  // Repositories
  final db = sqlite3.open('database.db');
  getIt.registerLazySingleton<PostsRepository>(() => PostsRepository(db));
  getIt.registerLazySingleton<UsersRepository>(() => UsersRepository(db));
  // Services
  getIt.registerLazySingleton<AuthService>(
    () => AuthService(getIt(), getIt(), getIt()),
  );
  // Controllers
  final authController = _$AuthController(getIt());
  router.mount('/auth', authController.handler);
  // Server Configuration
  Handler handler = router.call;
  final serverConfiguration = ServerConfiguration();
  for (final middleware in serverConfiguration.middlewares) {
    handler = middleware(handler);
  }
  SpringDartDefaults.instance.toEncodable = serverConfiguration.toEncodable;
  return await serverConfiguration.setup(
    SpringDart((request) => _exceptionHandler(handler, request)),
  );
}

class _$AuthController extends AuthController {
  const _$AuthController(super.authService);

  FutureOr<Response> handler(Request request) async {
    final router = Router();

    router.post('/sign-up', (Request request) async {
      final $json = await request.readAsString();
      final $body = Map<String, dynamic>.from(json.decode($json));
      final $dson = DSON();
      final dto = $dson.fromJson<SignUpDto>($body, SignUpDto.new);
      return signUp(dto);
    });

    router.post('/sign-in', (Request request) async {
      final $json = await request.readAsString();
      final $body = Map<String, dynamic>.from(json.decode($json));
      final $dson = DSON();
      final dto = $dson.fromJson<SignInDto>($body, SignInDto.new);
      return signIn(dto);
    });

    router.post('/sign-out', (Request request) async {
      return signOut();
    });

    router.post('/refresh-token', (Request request) async {
      final $json = await request.readAsString();
      final body = Map<String, dynamic>.from(json.decode($json));
      return refreshToken(body);
    });
    return router.call(request);
  }
}

// GENERATED BY SPRING_DART_SQL - DO NOT MODIFY BY HAND

class PostsRepository {
  final Database db;
  const PostsRepository(this.db);

  Future<PostEntity> insertOne(PostsInsertOneParams params) async {
    try {
      final query =
          'INSERT INTO posts (id, title, body, user_id) VALUES (?, ?, ?, ?) RETURNING *;';

      final values = [params.id, params.title, params.body, params.userId];

      final stmt = db.prepare(query);

      final result = stmt.select(values);

      if (result.isEmpty) {
        throw Exception('Failed to insert posts!');
      }

      final row = result.first;

      final copy = Map<String, dynamic>.from(row);
      copy['created_at'] = DateTime.parse(copy['created_at']);
      copy['updated_at'] = DateTime.parse(copy['updated_at']);
      return DSON().fromJson<PostEntity>(
        copy,
        PostEntity.new,
        aliases: {
          PostEntity: {
            'id': 'id',
            'title': 'title',
            'body': 'body',
            'userId': 'user_id',
            'createdAt': 'created_at',
            'updatedAt': 'updated_at',
          },
        },
      );
    } on Exception catch (e) {
      throw Exception('Failed to insert posts: $e');
    }
  }

  Future<PostEntity?> findOne(PostsFindOneParams params) async {
    try {
      final query = 'SELECT * FROM posts WHERE id = ?;';

      final values = [params.id];

      final stmt = db.prepare(query);

      final result = stmt.select(values);

      if (result.isEmpty) return null;

      final row = result.first;

      final copy = Map<String, dynamic>.from(row);
      copy['created_at'] = DateTime.parse(copy['created_at']);
      copy['updated_at'] = DateTime.parse(copy['updated_at']);
      return DSON().fromJson<PostEntity>(
        copy,
        PostEntity.new,
        aliases: {
          PostEntity: {
            'id': 'id',
            'title': 'title',
            'body': 'body',
            'userId': 'user_id',
            'createdAt': 'created_at',
            'updatedAt': 'updated_at',
          },
        },
      );
    } on Exception catch (e) {
      throw Exception('Failed to find posts: $e');
    }
  }

  Future<List<PostEntity>> findMany(PostsFindManyParams params) async {
    try {
      final where = params.where;

      final query = switch (where != null) {
        true => 'SELECT * FROM posts WHERE ${where?.query}',
        false => 'SELECT * FROM posts;',
      };

      final values = switch (where != null) {
        true => where?.values ?? [],
        false => [],
      };

      final stmt = db.prepare(query);

      final result = stmt.select(values);

      return result.map((row) {
        final copy = Map<String, dynamic>.from(row);
        copy['created_at'] = DateTime.parse(copy['created_at']);
        copy['updated_at'] = DateTime.parse(copy['updated_at']);
        return DSON().fromJson<PostEntity>(
          copy,
          PostEntity.new,
          aliases: {
            PostEntity: {
              'id': 'id',
              'title': 'title',
              'body': 'body',
              'userId': 'user_id',
              'createdAt': 'created_at',
              'updatedAt': 'updated_at',
            },
          },
        );
      }).toList();
    } on Exception catch (e) {
      throw Exception('Failed to find posts: $e');
    }
  }

  Future<PostEntity> updateOne(PostsUpdateOneParams params) async {
    try {
      if (params.toMap().isEmpty) {
        throw Exception(
          'Failed to update posts, you need to provide at least one field!',
        );
      }

      final query =
          'UPDATE posts SET ${params.toMap().keys.map((k) => '$k = ?').join(', ')} WHERE id = ? RETURNING *;';

      final values = [...params.toMap().values, params.id];

      final stmt = db.prepare(query);

      final result = stmt.select(values);

      if (result.isEmpty) {
        throw Exception('Failed to update posts!');
      }

      final row = result.first;

      final copy = Map<String, dynamic>.from(row);
      copy['created_at'] = DateTime.parse(copy['created_at']);
      copy['updated_at'] = DateTime.parse(copy['updated_at']);
      return DSON().fromJson<PostEntity>(
        copy,
        PostEntity.new,
        aliases: {
          PostEntity: {
            'id': 'id',
            'title': 'title',
            'body': 'body',
            'userId': 'user_id',
            'createdAt': 'created_at',
            'updatedAt': 'updated_at',
          },
        },
      );
    } on Exception catch (e) {
      throw Exception('Failed to update posts: $e');
    }
  }

  Future<PostEntity> deleteOne(PostsDeleteOneParams params) async {
    try {
      final query = 'DELETE FROM posts WHERE id = ? RETURNING *;';

      final values = [params.id];

      final stmt = db.prepare(query);

      final result = stmt.select(values);

      if (result.isEmpty) {
        throw Exception('Failed to delete posts!');
      }

      final row = result.first;

      final copy = Map<String, dynamic>.from(row);
      copy['created_at'] = DateTime.parse(copy['created_at']);
      copy['updated_at'] = DateTime.parse(copy['updated_at']);
      return DSON().fromJson<PostEntity>(
        copy,
        PostEntity.new,
        aliases: {
          PostEntity: {
            'id': 'id',
            'title': 'title',
            'body': 'body',
            'userId': 'user_id',
            'createdAt': 'created_at',
            'updatedAt': 'updated_at',
          },
        },
      );
    } on Exception catch (e) {
      throw Exception('Failed to delete posts: $e');
    }
  }
}

class PostsInsertOneParams {
  final int id;
  final String title;
  final String body;
  final int userId;

  const PostsInsertOneParams({
    required this.id,
    required this.title,
    required this.body,
    required this.userId,
  });
}

class PostsFindManyParams {
  final Where? where;
  const PostsFindManyParams(this.where);
}

class PostsFindOneParams {
  final int id;
  const PostsFindOneParams(this.id);
}

class PostsUpdateOneParams {
  final int id;
  final String? title;
  final String? body;
  final int? userId;
  final DateTime? createdAt;
  final DateTime? updatedAt;
  const PostsUpdateOneParams(
    this.id, {
    this.title,
    this.body,
    this.userId,
    this.createdAt,
    this.updatedAt,
  });

  Map<String, dynamic> toMap() => {
    if (title != null) 'title': title,
    if (body != null) 'body': body,
    if (userId != null) 'user_id': userId,
    if (createdAt != null) 'created_at': createdAt,
    if (updatedAt != null) 'updated_at': updatedAt,
  };
}

class PostsDeleteOneParams {
  final int id;
  const PostsDeleteOneParams(this.id);
}

// GENERATED BY SPRING_DART_SQL - DO NOT MODIFY BY HAND

class UsersRepository {
  final Database db;
  const UsersRepository(this.db);

  Future<UserEntity> insertOne(UsersInsertOneParams params) async {
    try {
      final query =
          'INSERT INTO users (name, email, password) VALUES (?, ?, ?) RETURNING *;';

      final values = [params.name, params.email, params.password];

      final stmt = db.prepare(query);

      final result = stmt.select(values);

      if (result.isEmpty) {
        throw Exception('Failed to insert users!');
      }

      final row = result.first;

      final copy = Map<String, dynamic>.from(row);
      copy['created_at'] = DateTime.parse(copy['created_at']);
      copy['updated_at'] = DateTime.parse(copy['updated_at']);
      return DSON().fromJson<UserEntity>(
        copy,
        UserEntity.new,
        aliases: {
          UserEntity: {
            'id': 'id',
            'name': 'name',
            'email': 'email',
            'password': 'password',
            'createdAt': 'created_at',
            'updatedAt': 'updated_at',
          },
        },
      );
    } on Exception catch (e) {
      throw Exception('Failed to insert users: $e');
    }
  }

  Future<UserEntity?> findOne(UsersFindOneParams params) async {
    try {
      final query = 'SELECT * FROM users WHERE id = ?;';

      final values = [params.id];

      final stmt = db.prepare(query);

      final result = stmt.select(values);

      if (result.isEmpty) return null;

      final row = result.first;

      final copy = Map<String, dynamic>.from(row);
      copy['created_at'] = DateTime.parse(copy['created_at']);
      copy['updated_at'] = DateTime.parse(copy['updated_at']);
      return DSON().fromJson<UserEntity>(
        copy,
        UserEntity.new,
        aliases: {
          UserEntity: {
            'id': 'id',
            'name': 'name',
            'email': 'email',
            'password': 'password',
            'createdAt': 'created_at',
            'updatedAt': 'updated_at',
          },
        },
      );
    } on Exception catch (e) {
      throw Exception('Failed to find users: $e');
    }
  }

  Future<List<UserEntity>> findMany(UsersFindManyParams params) async {
    try {
      final where = params.where;

      final query = switch (where != null) {
        true => 'SELECT * FROM users WHERE ${where?.query}',
        false => 'SELECT * FROM users;',
      };

      final values = switch (where != null) {
        true => where?.values ?? [],
        false => [],
      };

      final stmt = db.prepare(query);

      final result = stmt.select(values);

      return result.map((row) {
        final copy = Map<String, dynamic>.from(row);
        copy['created_at'] = DateTime.parse(copy['created_at']);
        copy['updated_at'] = DateTime.parse(copy['updated_at']);
        return DSON().fromJson<UserEntity>(
          copy,
          UserEntity.new,
          aliases: {
            UserEntity: {
              'id': 'id',
              'name': 'name',
              'email': 'email',
              'password': 'password',
              'createdAt': 'created_at',
              'updatedAt': 'updated_at',
            },
          },
        );
      }).toList();
    } on Exception catch (e) {
      throw Exception('Failed to find users: $e');
    }
  }

  Future<UserEntity> updateOne(UsersUpdateOneParams params) async {
    try {
      if (params.toMap().isEmpty) {
        throw Exception(
          'Failed to update users, you need to provide at least one field!',
        );
      }

      final query =
          'UPDATE users SET ${params.toMap().keys.map((k) => '$k = ?').join(', ')} WHERE id = ? RETURNING *;';

      final values = [...params.toMap().values, params.id];

      final stmt = db.prepare(query);

      final result = stmt.select(values);

      if (result.isEmpty) {
        throw Exception('Failed to update users!');
      }

      final row = result.first;

      final copy = Map<String, dynamic>.from(row);
      copy['created_at'] = DateTime.parse(copy['created_at']);
      copy['updated_at'] = DateTime.parse(copy['updated_at']);
      return DSON().fromJson<UserEntity>(
        copy,
        UserEntity.new,
        aliases: {
          UserEntity: {
            'id': 'id',
            'name': 'name',
            'email': 'email',
            'password': 'password',
            'createdAt': 'created_at',
            'updatedAt': 'updated_at',
          },
        },
      );
    } on Exception catch (e) {
      throw Exception('Failed to update users: $e');
    }
  }

  Future<UserEntity> deleteOne(UsersDeleteOneParams params) async {
    try {
      final query = 'DELETE FROM users WHERE id = ? RETURNING *;';

      final values = [params.id];

      final stmt = db.prepare(query);

      final result = stmt.select(values);

      if (result.isEmpty) {
        throw Exception('Failed to delete users!');
      }

      final row = result.first;

      final copy = Map<String, dynamic>.from(row);
      copy['created_at'] = DateTime.parse(copy['created_at']);
      copy['updated_at'] = DateTime.parse(copy['updated_at']);
      return DSON().fromJson<UserEntity>(
        copy,
        UserEntity.new,
        aliases: {
          UserEntity: {
            'id': 'id',
            'name': 'name',
            'email': 'email',
            'password': 'password',
            'createdAt': 'created_at',
            'updatedAt': 'updated_at',
          },
        },
      );
    } on Exception catch (e) {
      throw Exception('Failed to delete users: $e');
    }
  }
}

class UsersInsertOneParams {
  final String name;
  final String email;
  final String password;

  const UsersInsertOneParams({
    required this.name,
    required this.email,
    required this.password,
  });
}

class UsersFindManyParams {
  final Where? where;
  const UsersFindManyParams(this.where);
}

class UsersFindOneParams {
  final int id;
  const UsersFindOneParams(this.id);
}

class UsersUpdateOneParams {
  final int id;
  final String? name;
  final String? email;
  final String? password;
  final DateTime? createdAt;
  final DateTime? updatedAt;
  const UsersUpdateOneParams(
    this.id, {
    this.name,
    this.email,
    this.password,
    this.createdAt,
    this.updatedAt,
  });

  Map<String, dynamic> toMap() => {
    if (name != null) 'name': name,
    if (email != null) 'email': email,
    if (password != null) 'password': password,
    if (createdAt != null) 'created_at': createdAt,
    if (updatedAt != null) 'updated_at': updatedAt,
  };
}

class UsersDeleteOneParams {
  final int id;
  const UsersDeleteOneParams(this.id);
}

FutureOr<Response> _defaultNotFoundHandler(Request request) async {
  return Json(404, body: {'error': 'Route not found!'});
}

FutureOr<Response> _exceptionHandler(Handler handler, Request request) async {
  try {
    return await handler(request);
  } catch (e) {
    if (e is Exception) {
      return ServerControllerAdvice().exceptionHandler(e);
    } else if (e is ServerException) {
      return ServerControllerAdvice().serverExceptionHandler(e);
    } else {
      return Json(500, body: {'error': e.toString()});
    }
  }
}
