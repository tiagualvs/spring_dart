import 'package:analyzer/dart/element/element.dart';
import 'package:analyzer/dart/element/nullability_suffix.dart';
import 'package:spring_dart_gen/src/checkers.dart';
import 'package:spring_dart_gen/src/extensions/iterable_ext.dart';
import 'package:spring_dart_gen/src/extensions/string_ext.dart';
import 'package:spring_dart_sql/spring_dart_sql.dart';

String entityHelper(
  Driver driver,
  ClassElement element,
  Set<String> imports,
  Set<String> repositories,
  Set<({String name, String className, String content})> entities,
) {
  if (driver is NoneDriver) return '';

  final driverImport = switch (driver) {
    SqliteFileDriver _ || SqliteMemoryDriver _ => 'package:sqlite3/sqlite3.dart',
    _ => '',
  };

  imports.add(driverImport);

  final className = element.name;
  final tableName =
      tableChecker.firstAnnotationOf(element)?.getField('name')?.toStringValue() ??
      className?.removeSuffixes(['Entity', 'Model']);
  final repositoryName = '${tableName}Repository'.toPascalCase();
  final insertOneParamClassName = '${tableName}InsertOneParams'.toPascalCase();
  final findManyParamClassName = '${tableName}FindManyParams'.toPascalCase();
  final findOneParamClassName = '${tableName}FindOneParams'.toPascalCase();
  final updateOneParamClassName = '${tableName}UpdateOneParams'.toPascalCase();
  final deleteOneParamClassName = '${tableName}DeleteOneParams'.toPascalCase();

  final fields = element.fields.where((f) => f.name != 'hashCode' && f.name != 'runtimeType');

  if (!fields.any((f) => idChecker.hasAnnotationOf(f))) return '';

  imports.add('package:spring_dart_sql/spring_dart_sql.dart');

  imports.add(element.library.uri.toString());

  final driverClassName = switch (driver) {
    SqliteFileDriver _ || SqliteMemoryDriver _ => 'Database',
    _ => '',
  };

  final driverVarName = switch (driver) {
    SqliteFileDriver _ || SqliteMemoryDriver _ => 'db',
    _ => '',
  };

  final driverCreate = switch (driver) {
    SqliteMemoryDriver _ => <String>[
      'final db = sqlite3.openInMemory()',
    ],
    SqliteFileDriver d => <String>[
      'final db = sqlite3.open(\'${d.path}\')',
    ],
    _ => <String>[],
  };

  repositories.addAll(driverCreate);

  repositories.add('getIt.registerLazySingleton<$repositoryName>(() => $repositoryName(db))');

  final id = fields.firstWhereOrNull((f) => idChecker.hasAnnotationOf(f));

  final requiredFields = fields
      .where((f) => generatedValueChecker.hasAnnotationOf(f) == false)
      .where((f) => nullableChecker.hasAnnotationOf(f) == false)
      .where((f) => defaultChecker.hasAnnotationOf(f) == false);

  return '''// GENERATED BY SPRING_DART_SQL - DO NOT MODIFY BY HAND

class $repositoryName {
  final $driverClassName $driverVarName;
  const $repositoryName(this.$driverVarName);
  
  Future<$className> insertOne($insertOneParamClassName params) async {
    ${switch (driver) {
    SqliteFileDriver _ || SqliteMemoryDriver _ => _insertOneInSQLITE(driverVarName, tableName ?? '', className ?? '', fields.toList()),
    _ => '',
  }}
  }
  
  Future<$className?> findOne($findOneParamClassName params) async {
    ${switch (driver) {
    SqliteFileDriver _ || SqliteMemoryDriver _ => _findOneInSQLITE(driverVarName, tableName ?? '', className ?? '', fields.toList()),
    _ => '',
  }}
  }
  
  Future<List<$className>> findMany($findManyParamClassName params) async {
    ${switch (driver) {
    SqliteFileDriver _ || SqliteMemoryDriver _ => _findManyInSQLITE(driverVarName, tableName ?? '', className ?? '', fields.toList()),
    _ => '',
  }}
  }
  
  Future<$className> updateOne($updateOneParamClassName params) async {
    ${switch (driver) {
    SqliteFileDriver _ || SqliteMemoryDriver _ => _updateOneInSQLITE(driverVarName, tableName ?? '', className ?? '', fields.toList()),
    _ => '',
  }}
  }
  
  Future<$className> deleteOne($deleteOneParamClassName params) async {
    ${switch (driver) {
    SqliteFileDriver _ || SqliteMemoryDriver _ => _deleteOneInSQLITE(driverVarName, tableName ?? '', className ?? '', fields.toList()),
    _ => '',
  }}
  }
}
  
class $insertOneParamClassName {
  ${requiredFields.map((f) => 'final ${f.type.getDisplayString()} ${f.name};').join('\n')}

  const $insertOneParamClassName({
    ${requiredFields.map((f) => 'required this.${f.name},').join('\n')}
  });
}

class $findManyParamClassName {
  final Where? where;
  const $findManyParamClassName(this.where);
}

class $findOneParamClassName {
  ${id != null ? 'final ${id.type.getDisplayString()} ${id.name};' : ''}
  const $findOneParamClassName(${id != null ? 'this.${id.name}' : ''});
}

class $updateOneParamClassName {
  ${id != null ? 'final ${id.type.getDisplayString()} ${id.name};' : ''}
  ${fields.where((f) => f.name != id?.name).map((f) => 'final ${f.type.getDisplayString()}${f.type.nullabilitySuffix == NullabilitySuffix.none ? '?' : ''} ${f.name};').join('\n')}
  const $updateOneParamClassName(
    ${id != null ? 'this.${id.name}' : ''}
    ${fields.where((f) => f.name != id?.name).isNotEmpty ? ',{${fields.where((f) => f.name != id?.name).map((f) => 'this.${f.name}').join(',\n')}}' : ''}
  );

  Map<String, dynamic> toMap() => {
    ${fields.where((f) => f.name != id?.name).map((f) {
    final columnName = columnChecker.firstAnnotationOf(f)?.getField('name')?.toStringValue() ?? f.name;
    return 'if (${f.name} != null) \'$columnName\': ${f.name},';
  }).join('\n')}
  };
}

class $deleteOneParamClassName {
  ${id != null ? 'final ${id.type.getDisplayString()} ${id.name};' : ''}
  const $deleteOneParamClassName(${id != null ? 'this.${id.name}' : ''});
}''';
}

String _insertOneInSQLITE(
  String dialectVarName,
  String tableName,
  String className,
  List<FieldElement> fields,
) {
  final requiredFields = fields
      .where((f) => generatedValueChecker.hasAnnotationOf(f) == false)
      .where((f) => nullableChecker.hasAnnotationOf(f) == false)
      .where((f) => defaultChecker.hasAnnotationOf(f) == false);

  return '''try {
  final query = 'INSERT INTO $tableName (${requiredFields.map((f) {
    final column = columnChecker.firstAnnotationOf(f);
    final columnName = column?.getField('name')?.toStringValue() ?? '${f.name}';
    return columnName;
  }).join(', ')}) VALUES (${requiredFields.map((f) => '?').join(', ')}) RETURNING *;';

  final values = [${requiredFields.map((f) => 'params.${f.name}').join(', ')}];

  final stmt = $dialectVarName.prepare(query);

  final result = stmt.select(values);

  if (result.isEmpty) {
    throw Exception('Failed to insert $tableName!');
  }

  final row = result.first;

  final copy = Map<String, dynamic>.from(row);${fields.map((f) {
    final column = columnChecker.firstAnnotationOf(f);
    final columnName = column?.getField('name')?.toStringValue() ?? f.name;
    final columnType = column?.getField('type')?.type;
    if (dateTimeChecker.isExactlyType(f.type) || (columnType != null && timestampChecker.isExactlyType(columnType))) {
      return 'copy[\'$columnName\'] = DateTime.parse(copy[\'$columnName\']);\n';
    } else {
      return '';
    }
  }).join('')}return DSON().fromJson<$className>(
      copy, 
      $className.new,
      aliases: {
        $className: {
          ${fields.map((f) {
    final column = columnChecker.firstAnnotationOf(f)?.getField('name')?.toStringValue() ?? f.name;
    return '\'${f.name}\':\'$column\'';
  }).join(',\n')}
        }
      }
    );
} on Exception catch (e) {
  throw Exception('Failed to insert $tableName: \$e');
}''';
}

String _findOneInSQLITE(
  String dialectVarName,
  String tableName,
  String className,
  List<FieldElement> fields,
) {
  final id = fields.firstWhereOrNull((f) => idChecker.hasAnnotationOf(f));

  if (id == null) return '';

  final idName = columnChecker.firstAnnotationOf(id)?.getField('name')?.toStringValue() ?? id.name;

  return '''try {
    final query = 'SELECT * FROM $tableName WHERE $idName = ?;';

final values = [params.${id.name}];

final stmt = $dialectVarName.prepare(query);

final result = stmt.select(values);

if (result.isEmpty) return null;

final row = result.first;

final copy = Map<String, dynamic>.from(row);${fields.map((f) {
    final column = columnChecker.firstAnnotationOf(f);
    final columnName = column?.getField('name')?.toStringValue() ?? f.name;
    final columnType = column?.getField('type')?.type;
    if (dateTimeChecker.isExactlyType(f.type) || (columnType != null && timestampChecker.isExactlyType(columnType))) {
      return 'copy[\'$columnName\'] = DateTime.parse(copy[\'$columnName\']);\n';
    } else {
      return '';
    }
  }).join('')}return DSON().fromJson<$className>(
    copy, 
    $className.new,
    aliases: {
      $className: {
        ${fields.map((f) {
    final column = columnChecker.firstAnnotationOf(f)?.getField('name')?.toStringValue() ?? f.name;
    return '\'${f.name}\':\'$column\'';
  }).join(',\n')}
      }
    }
  );
  } on Exception catch (e) {
    throw Exception('Failed to find $tableName: \$e');
  }''';
}

String _findManyInSQLITE(
  String dialectVarName,
  String tableName,
  String className,
  List<FieldElement> fields,
) {
  return '''try {
    final where = params.where;

final query = switch (where != null) {
  true => 'SELECT * FROM $tableName WHERE \${where?.query}',
  false => 'SELECT * FROM $tableName;',
};

final values = switch (where != null) {
  true => where?.values ?? [],
  false => [],
};

final stmt = $dialectVarName.prepare(query);

final result = stmt.select(values);

return result.map((row) {
  final copy = Map<String, dynamic>.from(row);${fields.map((f) {
    final column = columnChecker.firstAnnotationOf(f);
    final columnName = column?.getField('name')?.toStringValue() ?? f.name;
    final columnType = column?.getField('type')?.type;
    if (dateTimeChecker.isExactlyType(f.type) || (columnType != null && timestampChecker.isExactlyType(columnType))) {
      return 'copy[\'$columnName\'] = DateTime.parse(copy[\'$columnName\']);\n';
    } else {
      return '';
    }
  }).join('')}return DSON().fromJson<$className>(
    copy, 
    $className.new,
    aliases: {
      $className: {
        ${fields.map((f) {
    final column = columnChecker.firstAnnotationOf(f)?.getField('name')?.toStringValue() ?? f.name;
    return '\'${f.name}\':\'$column\'';
  }).join(',\n')}
      }
    }
  );
}).toList();
  } on Exception catch (e) {
    throw Exception('Failed to find $tableName: \$e');
  }''';
}

String _updateOneInSQLITE(
  String dialectVarName,
  String tableName,
  String className,
  List<FieldElement> fields,
) {
  final id = fields.firstWhereOrNull((f) => idChecker.hasAnnotationOf(f));

  if (id == null) return '';

  return '''try {
    if (params.toMap().isEmpty) {
  throw Exception('Failed to update $tableName, you need to provide at least one field!');  
}

final query = 'UPDATE $tableName SET \${params.toMap().keys.map((k) => '\$k = ?').join(', ')} WHERE ${id.name} = ? RETURNING *;';

final values = [...params.toMap().values, params.${id.name}];

final stmt = $dialectVarName.prepare(query);

final result = stmt.select(values);

if (result.isEmpty) {
  throw Exception('Failed to update $tableName!');
}

final row = result.first;

final copy = Map<String, dynamic>.from(row);${fields.map((f) {
    final column = columnChecker.firstAnnotationOf(f);
    final columnName = column?.getField('name')?.toStringValue() ?? f.name;
    final columnType = column?.getField('type')?.type;
    if (dateTimeChecker.isExactlyType(f.type) || (columnType != null && timestampChecker.isExactlyType(columnType))) {
      return 'copy[\'$columnName\'] = DateTime.parse(copy[\'$columnName\']);\n';
    } else {
      return '';
    }
  }).join('')}return DSON().fromJson<$className>(
    copy, 
    $className.new,
    aliases: {
      $className: {
        ${fields.map((f) {
    final column = columnChecker.firstAnnotationOf(f)?.getField('name')?.toStringValue() ?? f.name;
    return '\'${f.name}\':\'$column\'';
  }).join(',\n')}
      }
    }
  );
  } on Exception catch (e) {
    throw Exception('Failed to update $tableName: \$e');
  }''';
}

String _deleteOneInSQLITE(
  String dialectVarName,
  String tableName,
  String className,
  List<FieldElement> fields,
) {
  final id = fields.firstWhereOrNull((f) => idChecker.hasAnnotationOf(f));

  if (id == null) return 'throw UnimplementedError();';

  return '''try {
    final query = 'DELETE FROM $tableName WHERE ${id.name} = ? RETURNING *;';

final values = [params.${id.name}];

final stmt = $dialectVarName.prepare(query);

final result = stmt.select(values);

if (result.isEmpty) {
  throw Exception('Failed to delete $tableName!');
}

final row = result.first;

final copy = Map<String, dynamic>.from(row);${fields.map((f) {
    final column = columnChecker.firstAnnotationOf(f);
    final columnName = column?.getField('name')?.toStringValue() ?? f.name;
    final columnType = column?.getField('type')?.type;
    if (dateTimeChecker.isExactlyType(f.type) || (columnType != null && timestampChecker.isExactlyType(columnType))) {
      return 'copy[\'$columnName\'] = DateTime.parse(copy[\'$columnName\']);\n';
    } else {
      return '';
    }
  }).join('')}return DSON().fromJson<$className>(
    copy, 
    $className.new,
    aliases: {
      $className: {
        ${fields.map((f) {
    final column = columnChecker.firstAnnotationOf(f)?.getField('name')?.toStringValue() ?? f.name;
    return '\'${f.name}\':\'$column\'';
  }).join(',\n')}
      }
    }
  );
  } on Exception catch (e) {
    throw Exception('Failed to delete $tableName: \$e');
  }''';
}
